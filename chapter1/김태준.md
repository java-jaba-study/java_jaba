## 1장 : 자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가?
### 1.1 역사의 흐름은 무엇인가?
 - 자바 역사를 통틀어 가장 큰 변화가 **자바 8**에서 일어났다.
    - 자바 8전에는 멀티 코어를 사용할여면 쓰레드를 사용해야 했다.(쓰레드는 관리가 어렵고 여러 동시성 이슈와 같은 문제가 발생 할 수 있다.)
    - 자바 8에서는 병렬 실행을 새롭고 단순한 방식으로 접근할 수 있는 방법을 제공한다.
    - 자바 8은 간결한 코드, 멀티코어 프로세서의 쉬운 활용이라는 두 가지 요구사항을 기반으로 한다.
 - 자바 8의 특징
   - 스트림 API : 병렬 연산 지원(직접 쓰레드를 만들지 않고, 동기화를 위해 syncronized를 사용할 필요가 없다.)
   - 메서드에 코드를 전달하는 기법
   - 인터페이스의 디폴트 메서드

### 1.2 왜 아직도 자바는 변화하는가?
 - 특정 분야에서 장점을 가진 언어는 다른 경쟁 언어를 도태시킨다.
#### 1.2.1. 프로그래밍 언어 생태계에서 자바의 위치
 - 초창기에는 출발이 좋았음(잘 설계된 객체지향, 스레드와 락 관련 동시성 지원)
 - 모튼 브라우저에서 가상 머신 코드를 지원하기 때문에 JVM 기반 언어인 자바는 인터넷 프로그램의 주요 언어가됨.(스칼라, 루비 대체)
 - 빅데이터라는 개념이 탄생하면서, 멀티코어, 클러스터링을 이용해 많은 양의 데이터를 효과적으로 처리해야 했다. -> 기존 자바로는 충분히 대응 불가능했다.
#### 1.2.2 스트림 처리
 - 스트림이란 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임이다.
 - 자바 8에는 java.util.stream 패키지에 스트림 API가 추가됨
 - 스트림 API의 핵심은 기존에는 한 번에 한 항목을 처리했지만 자바 8에서는 작업을 추상화 하여 일련의 스트림으로 만들어 처리 할 수 있다는 것이다.
#### 1.2.3. 동작 파라미터화로 메서드에 코드 전달하기
 - 자바 8에서는 메서드를 다른 메서드의 인수르 넘겨주는 기능을 제공한다.(동작 파라미터화)
 - 자바 8 전에는 sort함수의 파라미터로 Comparator를 구현해 줄 수 있음. 자바 8부터는 sort 함수로 특정함수를 주입시킬 수 있음? (소스로 확인 필요)
 #### 1.2.4 병렬성과 공유 가변 데이터
  - 스트림 API를 사용하면 syncronized를 사용하지 않고도 동시성 문제를 처리할 수 있지만, 스트림 메서드로 전달하는 코드의 동작 방식을 조금 바꿔야 된다? (어떻게 바꾸는지? 어떻게 syncronized를 안쓰고 동시성 처리가 가능한지에 대해서는 책 뒤에 나오는 듯 하다..)
#### 1.2.5 자바가 진화해야 하는 이유
 - 하드웨어나 프로그래머 기대의 변화에 부응하기 위해... 도태되어 사용되지 않는 언어가 되지 않기 위해 계속 진화해야 한다고 이야기한다.

### 1.3 자바 함수
 - 자바 8에서는 함수를 새로운 값의 형식으로 추가했다.(멀티코어에서 병렬 프로그래밍을 활용할 수 있는 스트림과 연계될 수 있도록 함수를 만듬)
#### 1.3.1. 메서드와 람다를 일급 시민으로
 - 메서드 참조
 - 특정 디렉토리 밑에 숨겨진 파일을 찾는 방법 (자바 8 이전)
 ```
   File[] hiddenFiles = new File(".").listFiles(new FileFilter() {
      public boolean accept(File file) {
         return file.isHidden(); // 숨겨진 파일 필터링
      }
   })

 ```
  - 특정 디렉토리 밑에 숨겨진 파일을 찾는 방법 (자바 8 이후) -> 파라미터로 메서드 전달 가능!
 ```
   File[] hiddenFiles = new File(".").listFiles(File::isHidden);
 ```
 #### 람다 : 익명 함수
  - 자바 8에서는 메서드를 일급값으로 취급할 뿐 아니라 람다를 포함하여 함수도 값으로 취급할 수 있다.

#### 1.3.2. 코드 넘겨주기 : 예제
 - 책의 소스 참고(Predicate를 사용하여 소스의 유지보수를 쉽게 해준다. - 함수 1개로 여러 필터링 조건을 사용 할 수 있기때문에 소스코드의 중복이 제거된다.)

#### 1.3.3 메서드 전달에서 람다로
- 한 두번만 사용할 메서드를 매번 정의해서 사용하기 귀찮아서, 람다를 통해 바로 정의해서 사용할 수 있다.
```
   filterApples(inventory, (Apple a) -> GREEN.equals(a.getColor()));
   filterApples(inventory, (Apple a) -> a.getWeight() > 150);
```

- 즉, 한 번만 사용할 메서드는 따로 정의를 구현할 필요가 없다. 

#### 1.4. 스트림
- 스트림(filter, collect..등)API를 사용하면 코드를 간결하게 작성 할 수 있다.
- 소스는 간결하지만 처리량이 많을 경우 성능이 좋지 않다.(기본 stream은 멀티 코어를 사용하지 않음)
#### 1.4.1 멀티쓰레등은 어렵다.
 - 쓰레드 API로 멀티쓰레딩은 고려해 줘야할 것들이 많다.(쓰레드를 직접 생성하는 것 부터 동기화 처리까지 고려해줘야 할 것들이 많다.)
 - 자바 8은 스트림 API로 "컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제" 그리고 "멀티코어 활용 어려움"이라는 두 가지 문제를 모두 해결했다.
 - 반복되는 패턴의 경우 조건에 따라 **필터링**을 하거나, 데이터를 **추출** 하거나 데이터를 **그룹화**를 하는 기능이 있다.
 - 하나의 작업을 여러 cpu가 병렬로 처리 한 후(포킹단계) 합쳐서 결과를 리턴한다. (
컬렉션을 스트림으로 바꾸고, 병렬로 처리한 다음, 리스트로 다시 복원한다.)

- 순차 처리 코드
```
   List<Apple> heavyApples = inventory.stream().filter((Apple a) -> a.getWeight() > 150)
                                               .collect(toList());
```

- 병렬 처리 코드
```
 List<Apple> heavyApples = inventory.parallelStream().filter((Apple a) -> a.getWeight() > 150)
                                               .collect(toList());
```

### 1.5 디폴트 메서드와 자바 모듈
 - 자바 8은 구현 클래스에서 구현하지 않아도 되는 메서더르르 인터페이스에 추가 할 수 있는 기능을 제공한다.
 - 디폴트 메서드를 이용하면 기존의 코드를 건드리지 않고도 원래의 인터페이스 설계를 자유롭게 확장 할 수 있다.(디폴트 메서드가 없는 자바 7이하의 버전에서는 특정 인터페이스에 메서들르 추가한다면 해당 인터페이스를 구현하고 있는 모든 구현체에 해당 함수를 오버라이드 해줘야 했다.)
 - 자바 8에서는 인터페이스 규격 명세에 default라는 새로운 키워드를 지원한다.(ex. List의 sort 메서드)

 ### 한줄 정리
  - 자바 8의 스트림 API를 통해 코드의 간결성(함수를 파라미터로 전달)과 병렬성(멀티 코어 사용)의 이점을 갖을 수 있다.

